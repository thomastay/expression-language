package ast

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/alecthomas/participle/v2/lexer"
)

// # Grammmar
// Start : E
// E : V
//   | E op E
//   | uop E
//   | ( E )
//   | E ? E : E
//   | E [ E ]
//   | Call
//   | KArr
//   | EFieldAccess
//
// Call: Ident ( EList )
//     | E . Ident ( EList )
//
// EFieldAccess : E . Ident
//
// EList : E ',' EList
//       | E
//
// V : Ident | Int | Float | KStr | true | false
//
// KArr  : [ VList ]
// VList : V ',' VList
//       | V

type Expr interface {
	isExpr()
	String() string
}

// The number of nodes generated by the parser. Note that the compiler also has some more node types
var NumASTNodeTypes = 8

func (x *EValue) isExpr()       {}
func (x *EBinOp) isExpr()       {}
func (x *EUnOp) isExpr()        {}
func (x *EFieldAccess) isExpr() {}
func (x *EIdxAccess) isExpr()   {}
func (x *ECond) isExpr()        {}
func (x *ECall) isExpr()        {}
func (x *EArray) isExpr()       {}

var NumASTTotalNodeTypes = NumASTNodeTypes + 5

func (x *EInt) isExpr()   {}
func (x *EFloat) isExpr() {}
func (x *EStr) isExpr()   {}
func (x *EIdent) isExpr() {}
func (x *EBool) isExpr()  {}

//  Handy switch statement for your use
//	switch node := expr.(type) {
//	case *EValue:
//	case *EInt:
//	case *EFloat:
//	case *EStr:
//	case *EIdent:
//	case *EBool:
//	case *EUnOp:
//	case *EBinOp:
//	case *EFieldAccess:
//	case *EIdxAccess:
//	case *ECond:
//	case *ECall:
//	case *EArray:
//	default:
//		panic("AST type is not impl")
//	}

type EValue struct {
	Val *lexer.Token
}
type EBinOp struct {
	Left  Expr
	Op    *lexer.Token
	Right Expr
}
type EUnOp struct {
	Op  *lexer.Token
	Val Expr
}
type EIdxAccess struct {
	Base  Expr
	Index Expr
}
type EFieldAccess struct {
	Base  Expr
	Field *lexer.Token
}
type ECond struct {
	Cond   Expr
	First  Expr
	Second Expr
}
type ECall struct {
	Base   Expr         // ( @@ "." )?`
	Method *lexer.Token // @Ident`
	Exprs  ExprList     // ( @@ )?`
}
type ExprList []Expr
type EArray []Expr // "[" ( @@ ( "," @@ )* )? "]"`

type EInt int64
type EFloat float64
type EStr string
type EIdent string
type EBool bool

func (x *EValue) String() string {
	return x.Val.String()
}

func (x *EBinOp) String() string {
	return fmt.Sprintf("(%s %s %s)", x.Left, string(x.Op.Value), x.Right)
}

func (x *EUnOp) String() string {
	return fmt.Sprintf("(%s %s)", string(x.Op.Value), x.Val)
}

func (x *EIdxAccess) String() string {
	return fmt.Sprintf("%s[%s]", x.Base, x.Index)
}

func (x *EFieldAccess) String() string {
	return fmt.Sprintf("(%s.%s)", x.Base, x.Field)
}

func (x *ECond) String() string {
	return fmt.Sprintf("(%s ? %s : %s)", x.Cond, x.First, x.Second)
}

func (x *ECall) String() string {
	if x.Base != nil {
		return fmt.Sprintf("%s.%s(%s)", x.Base, x.Method, x.Exprs)
	}
	return fmt.Sprintf("%s(%s)", x.Method, x.Exprs)
}

func (es ExprList) String() string {
	if es == nil {
		return ""
	}
	exprs := make([]string, 0, len(es))
	for _, val := range es {
		if val != nil {
			exprs = append(exprs, val.String())
		}
	}
	return strings.Join(exprs, ", ")
}

func (x *EArray) String() string {
	if x == nil {
		return ""
	}
	exprs := make([]string, len(*x))
	for i, val := range *x {
		exprs[i] = val.String()
	}
	return fmt.Sprintf("[%s]", strings.Join(exprs, ", "))
}

func (x *EInt) String() string {
	return strconv.FormatInt(int64(*x), 10)
}
func (x *EFloat) String() string {
	return strconv.FormatFloat(float64(*x), 'e', 3, 64)

}
func (x *EStr) String() string {
	return string(*x)
}
func (x *EIdent) String() string {
	return string(*x)
}
func (x *EBool) String() string {
	return strconv.FormatBool(bool(*x))
}
